{
    "collab_server" : "",
    "contents" : "# ========================================================================\n# Imena in razpredelnice \n#\n# Do komponent vektorjev lahko dostopamo tudi z njihovimi imeni. Na primer\n# `islands` je vektor površin največjih otokov na Zemlji. Do komponent lahko\n# dostopamo kot poprej\n# \n#     islands[c(13, 16, 8)] # 13., 16. in 8. otok, urejeno po abecedi\n#     islands[islands < 100] # otoki s površino, manjšo od 100 kvadratnih milj\n# \n# ali direktno po imenih\n# \n#     islands[\"Britain\"] # površina Velike Britanije\n#     islands[c(\"Honshu\", \"Kyushu\", \"Hokkaido\", \"Shikoku\")] # Japonski otoki\n# \n# Če imena ni, dobimo vrednost NA (not available).\n# \n#     islands[\"Blejski otok\"]\n# \n# V ozadju R uporablja vektor imen, do katerega lahko dostopamo z ukazom\n# \n#     names(islands)\n# \n# Vektorje z imeni lahko s funkcijo `c` sestavimo tudi direktno\n# \n#     matematika <- c(4, 2, 5, 3)\n#     names(matematika) <- c(\"Janez\", \"Micka\", \"Lojzka\", \"Franci\")\n# \n# Če želimo uvesti urejenost za imenske spremenljivke, si lahko pomagamo s\n# funkcijo `factor`.\n# \n#     opisne.ocene <- c(\"manj uspešno\", \"uspešno\", \"zelo uspešno\")\n#     telovadba <- c(\"manj uspešno\", \"zelo uspešno\", \"uspešno\", \"uspešno\")\n#     Telovadba <- factor(telovadba, levels = opisne.ocene, ordered = TRUE)\n# \n# S funkcijo `data.frame` lahko podatke iz vektorjev spravimo v razpredelnico.\n# \n#     Sola <- data.frame(matematika, sportna.vzgoja = Telovadba)\n# \n# Iz razpredelnice lahko dobimo posamezne vrstice in stolpce oziroma celice.\n# \n#     Sola[\"Franci\",]\n#     Sola[, \"matematika\"]\n#     Sola[\"Micka\", \"sportna.vzgoja\"]\n# ================================================================@003574=\n# 1. podnaloga\n# Sestavite vektor `otoki`, ki vsebuje iste podatke kot vektor `islands`,\n# le da so površine izražene v kvadratnih kilometrih.\n# ========================================================================\n\n# ================================================================@003575=\n# 2. podnaloga\n# Sestavi razpredelnico `Otoki` s podatki iz vektorjev `islands` in\n# `otoki` s stolpci `kvadratni.kilometri`, `kvadratne.milije` in\n# `kategorija`, pri čemer je zadnja urejenostna spremenljivka z\n# vrednostmi\n# \n# * `\"celina\"`, če je površina otoka nad 5000 km^2,\n# * `\"velik otok\"`, če je površina med 100 km^2 in 5000 km^2,\n# * `\"majhen otok\"`, če je površina pod 100 km^2.\n# \n# Velikosti v kvadratnih kilometrih naj bodo zaokrožene na celo število.\n# ========================================================================\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# =======================================================================@\n# Kode pod to črto nikakor ne spreminjajte.\n# ========================================================================\n\n\"TA VRSTICA JE PRAVILNA.\"\n\"ČE VAM R SPOROČI, DA JE V NJEJ NAPAKA, SE MOTI.\"\n\"NAPAKA JE NAJVERJETNEJE V ZADNJI VRSTICI VAŠE KODE.\"\n\"ČE JE NE NAJDETE, VPRAŠAJTE ASISTENTA.\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif (length(showConnections()) > 1) {\n  .filename <- showConnections()[1, \"description\"]\n} else {\n  .filename <- Find(Negate(is.null), Map(function(f) { f$ofile }, sys.frames()), right=TRUE)\n}\n\n\n.check <- function() {\n  .error <- FALSE\n.errfun <- function(e) {\n    warning(e)\n    .error <<- TRUE\n}\ntryCatch({\n    library(rjson)\n}, error = .errfun)\ntryCatch({\n    library(httr)\n}, error = .errfun)\n\nif (.error) {\n    stop(\"Required libraries are unavailable. Please make sure that rjson and httr are available.\")\n}\n\nregex_break <- function(whole_regex, regexes, source) {\n    whole_matches <- gregexpr(paste(\"(?sm)\", whole_regex, sep=\"\"), source, perl=TRUE)[[1]]\n    whole_matches <- mapply(\n        function(start, end) substr(source, start, end),\n        whole_matches,\n        whole_matches + attr(whole_matches, \"match.length\") - 1\n    )\n    m <- length(whole_matches)\n    n <- length(regexes)\n    matches <- matrix(\"\", nrow=m, ncol=n)\n    for (i in 1:m) {\n        whole <- whole_matches[i]\n        for (j in 1:n) {\n            rest_regex <- paste(regexes[-(1 : j)], collapse=\"\")\n            part_regex <- paste(\"(?sm)\\\\A\", regexes[j], \"(?=\", rest_regex, \"\\\\Z)\", sep=\"\")\n            match <- regexpr(part_regex, whole, perl=TRUE)\n            end <- attr(match, \"match.length\")\n            matches[i, j] <- substr(whole, 1, end)\n            whole <- substr(whole, end + 1, nchar(whole))\n        }\n    }\n    matches\n}\n\nstrip <- function(str) gsub(\"^\\\\s+|\\\\s+$\", \"\", str)\nrstrip <- function(str) gsub(\"\\\\s+$\", \"\", str)\n\nsuper_strip <- function(str) {\n    str <- gsub(\"(^|\\n)# ?\", \"\\n\", str)\n    gsub(\"\\\\A\\\\s+|\\\\s+\\\\Z\", \"\", str, perl=TRUE)\n}\n\npretty.print <- function(x) {\n  output <- capture.output(print(x))\n  if(length(output) == 0) {\n    return(\"NULL\")\n  } else if(length(output) == 1) {\n    return(output)\n  } else {\n    return(paste(\"    \", c(\"\", output, \"\"), collapse = \"\\n\"))\n  }\n}\n\n\n  check <- list()\n\ncheck$initialize <- function(parts) {\n  init.part <- function(part) {\n    part$valid <- TRUE\n    part$feedback <- list()\n    part$secret <- list()\n    if (part$part) part$id <- part$part\n    return(part)\n  }\n  check$parts <<- lapply(parts, init.part)\n  check$current <<- NA\n  check$part.counter <<- NA\n}\n\ncheck$part <- function() {\n  if(is.na(check$part.counter)) {\n    check$part.counter <<- 1\n  } else {\n    check$part.counter <<- check$part.counter + 1\n  }\n  return(strip(check$parts[[check$part.counter]]$solution) != \"\")\n}\n\ncheck$feedback <- function(msg, ...) {\n  check$parts[[check$part.counter]]$feedback <<-\n    c(check$parts[[check$part.counter]]$feedback, sprintf(msg, ...))\n}\n\ncheck$error <- function(msg, ...) {\n  check$parts[[check$part.counter]]$valid <<- FALSE\n  check$feedback(msg, ...)\n}\n\ncheck$secret <- function(x, hint = \"\") {\n  pair <- c(toString(check$canonize(x)), toString(hint))\n  check$parts[[check$part.counter]]$secret<<-\n    c(check$parts[[check$part.counter]]$secret, list(pair))\n}\n\ncheck$run <- function(example, state) {\n  # yet to be implemented\n}\n\ncheck$canonize <- function(x, digits = 6) {\n  if(typeof(x) == \"double\" || typeof(x) == \"complex\") {\n    return(round(x, digits))\n  } else if(typeof(x) == \"list\") {\n    return(lapply(x, function(y) check$canonize(y, digits)))\n  } else {\n    return(x)\n  }\n}\n\ncheck$equal <- function(example, value = NA, exception = NA,\n                        clean = function(x) x,\n                        precision = 1.0e-6, strict.float = FALSE, check.attributes = FALSE) {\n  difference <- function(x, y) {\n    if(identical(x, y)) return(NA)\n    else if(isTRUE(all.equal(x, y, check.attributes = check.attributes))) return(NA)\n    else if(typeof(x) != typeof(y) && (strict.float || !(mode(x) != mode(y))))\n      return(\"različna tipa\")\n    else if(length(x) != length(y))\n      return(\"različno število komponent\")\n    else if(mode(x) == 'numeric' && mode(y) == 'numeric') {\n      if(any(abs(x - y) > precision))\n        return(\"numerična napaka\")\n      else\n        return(NA)\n    }\n    else return(\"različni vrednosti\")\n  }\n  example <- substitute(example)\n\n  if(!is.na(exception)) {\n    tryCatch({\n      returned <- eval(example)\n      check$error(\"Izraz %s vrne %s namesto da bi sprožil izjemo '%s'.\",\n                  deparse(example), pretty.print(returned), exception)\n    }, error = function(e) {\n      if(e$message != exception)\n        check$error(\"Izraz %s sproži izjemo '%s' namesto '%s'.\",\n                    deparse(example), e$message, exception)\n    })\n  } else {\n    returned <- eval(example)\n    reason <- difference(clean(returned), clean(value))\n    if(!is.na(reason)) {\n      check$error(\"Izraz %s vrne %s namesto %s (%s)\",\n                  deparse(example), pretty.print(returned), pretty.print(value), reason)\n    }\n  }\n}\n\ncheck$random <- function(example, period = 10, sample = 100, uniqueness = 0.9) {\n  example <- substitute(example)\n  results <- replicate(sample, toString(check$canonize(replicate(period, eval(example)))))\n  if (length(unique(results)) < uniqueness * sample) {\n    check$error(\"Izraz %s ne vrača naključnih rezultatov.\", deparse(example))\n  }\n}\n\ncheck$probability <- function(example, interval, sample = 100) {\n  example <- substitute(example)\n  results <- replicate(sample, isTRUE(eval(example)))\n  prob <- sum(results) / sample\n  if (!(interval[1] < prob && prob <= interval[2])) {\n    check$error(\"Izraz %s velja z verjetnostjo %.2f, ki je izven pričakovanega intervala [%.2f, %.2f].\", deparse(example), prob, interval[1], interval[2])\n  }\n}\n\ncheck$expected <- function(example, interval, sample = 100) {\n  example <- substitute(example)\n  results <- replicate(sample, eval(example))\n  prob <- sum(results) / sample\n  if (!(interval[1] < prob && prob <= interval[2])) {\n    check$error(\"Povprečna vrednost izraza %s je %.2f, kar je izven pričakovanega intervala [%.2f, %.2f].\", deparse(example), prob, interval[1], interval[2])\n  }\n}\n\ncheck$summarize <- function() {\n  for(i in 1:length(check$parts)) {\n    if(strip(check$parts[[i]]$solution) == \"\") {\n      cat(\"Podnaloga\", i, \"je brez rešitve.\\n\")\n    } else if (! check$parts[[i]]$valid) {\n      cat(\"Podnaloga\", i, \"nima veljavne rešitve.\\n\")\n    } else {\n      cat(\"Podnaloga\", i, \"ima veljavno rešitev.\\n\")\n    }\n    for (message in check$parts[[i]]$feedback) {\n        cat(\"- \", message, \"\\n\", sep = \"\")\n    }\n  }\n}\n\n  check$challenge <- check$secret\n\n  .source <- paste(readLines(.filename), collapse=\"\\n\")\n\n  matches <- regex_break(paste(\n      '# =+@(\\\\d+)=\\n',    # beginning of header\n      '(#( [^\\n]*)?\\n)+',  # description\n      '# =+\\n',            # end of header\n      '.*?',               # solution\n      '(?=\\n# =+@)',       # beginning of next part\n      sep=\"\"\n  ),  c(\n      '# =+@',             # beginning of header\n      '(\\\\d+)',            # beginning of header (?P<part>)\n      '=\\n',               # beginning of header\n      '(#( [^\\n]*)?\\n)+',  # description\n      '# =+\\n',            # end of header\n      '.*?'                # solution\n  ), .source)\n\n  check$initialize(\n    apply(matches, 1, function(match) list(\n        part = as.numeric(match[2]),\n        solution = match[6]\n      )\n    )\n  )\n  check$parts[[length(check$parts)]]$solution <- rstrip(check$parts[[length(check$parts)]]$solution)\n\n  \n  if (check$part()) {\n    tryCatch({\n      check$equal(round(otoki['Java'], 3), 126.909)\n      check$equal(round(otoki['Britain'], 3), 217.559)\n    },\n    error = function(e) {\n      check$error(\"Testi v izrazu %s sprožijo izjemo %s\", deparse(e$call), e$message)\n    })\n  }\n  \n  if (check$part()) {\n    tryCatch({\n      if(!is.data.frame(Otoki)) {\n        check$error(\"Spremenljivka Otoki ni razpredelnica.\")\n      }\n      if(any(names(Otoki) != c(\"kvadratni.kilometri\", \"kvadratne.milije\", \"kategorija\"))) {\n        check$error(\"Razpredelnica Otoki nima pravih stolpcev.\")\n      }\n      if(!is.ordered(Otoki[,\"kategorija\"])) {\n        check$error(\"Stolpec kategorija ni urejenostna spremenljivka.\")\n      }\n      if(!all(Otoki[Otoki[\"kategorija\"] == \"celina\",\"kvadratni.kilometri\"] > 5000)\n         || !all(Otoki[Otoki[\"kategorija\"] == \"velik otok\",\"kvadratni.kilometri\"] >= 100)\n         || !all(Otoki[Otoki[\"kategorija\"] == \"majhen otok\",\"kvadratni.kilometri\"] < 100)) {\n        check$error(\"Kategorije niso pravilno dodeljene!.\")\n      }\n      if(Otoki[\"Europe\", \"kategorija\"] <= Otoki[\"Baffin\", \"kategorija\"]\n         || Otoki[\"Borneo\", \"kategorija\"] <= Otoki[\"Banks\", \"kategorija\"]) {\n        check$error(\"Kategorije niso pravilno razvrščene!.\")\n      }\n      check$equal(Otoki['Java', \"kvadratni.kilometri\"], 127)\n      check$equal(Otoki['Britain', \"kvadratne.milije\"], 84)\n    },\n    error = function(e) {\n      check$error(\"Testi v izrazu %s sprožijo izjemo %s\", deparse(e$call), e$message)\n    })\n  }\n  \n\n  cat('Shranjujem rešitve na strežnik... ')\n  tryCatch({\n    r <- POST(\n      'https://www.projekt-tomo.si/api/attempts/submit/',\n      body = lapply(check$parts, function(part) {\n        part$secret <- lapply(part$secret, function(x) x[1])\n        part\n      }),\n      encode = \"json\",\n      add_headers(Authorization = 'Token 840c6db2891f669ba2f3e6e7088911585701a262')\n    )\n    response <- content(r)\n    cat('Rešitve so shranjene.\\n')\n    updates <- list()\n    for (part in response$attempts) {\n      updates[[part$part]] <- part\n    }\n    for(i in 1:length(check$parts)) {\n      valid.before <- check$parts[[i]]$valid\n      if (!is.null(updates[[check$parts[[i]]$part]])) {\n        for (field in names(updates[[check$parts[[i]]$part]])) {\n          check$parts[[i]][[field]] <- updates[[check$parts[[i]]$part]][[field]]\n        }\n      }\n      valid.after <- check$parts[[i]]$valid\n      if (valid.before && ! valid.after) {\n        wrong.index <- response$wrong_indices[[as.character(check$parts[[i]]$part)]]\n        if (! is.null(wrong.index)) {\n          hint <- check$parts[[i]]$secret[[wrong.index+1]][2]\n          if (nchar(hint) > 0) {\n            check$parts[[i]]$feedback <- c(check$parts[[i]]$feedback, paste(\"Namig:\", hint))\n          }\n        }\n      }\n    }\n    if(\"update\" %in% names(response)) {\n      cat(\"Posodabljam datoteko... \")\n      index <- 1\n      while(file.exists(paste(.filename, \".\", index, sep = \"\")))\n        index <- index + 1\n      backup.filename = paste(.filename, \".\", index, sep = \"\")\n      file.copy(.filename, backup.filename)\n      r <- readLines(response$update, encoding=\"UTF-8\", warn=FALSE)\n      f <- file(.filename, encoding=\"UTF-8\")\n      writeLines(r, f)\n      close.connection(f)\n      cat(\"Stara datoteka je preimenovana v \", basename(backup.filename), \".\\n\", sep = \"\")\n      cat(\"Če se datoteka v urejevalniku ni osvežila, jo shranite ter ponovno zaženite.\\n\")\n    }\n    check$summarize()\n  },\n  error = function(r) {\n    cat('Pri shranjevanju je prišlo do napake.\\n')\n    check$summarize()\n    cat('Pri shranjevanju je prišlo do napake. Poskusite znova.\\n')\n  })\n}\n\n.check()\n",
    "created" : 1488191955983.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1902255364",
    "id" : "D7173A8",
    "lastKnownWriteTime" : 1488188242,
    "last_content_update" : 1488188242,
    "path" : "U:/ANALIZA PODATKOV S PROGRAMOM R/VEKTORJI IN RAZPREDELNICE/imena_in_razpredelnice.r",
    "project_path" : "imena_in_razpredelnice.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}