{
    "collab_server" : "",
    "contents" : "# ========================================================================\n# Osnovni gradniki vektorjev \n#\n# Osnovne vektorje pišemo kot `c(x1, x2, ...)`\n# \n#      c(1, 2, 3, 4, 5, 6, 7)\n# \n# V resnici je `c` ukaz, ki več vektorjev stakne v enega, in zgornji zapis\n# predstavlja le stikanje več vektorjev dolžine 1.\n# \n#      c(c(1, 2, 3), c(4, 5, 6))\n# \n# Za ustvarjanje novih vektorjev nam je na voljo veliko ukazov\n# \n#      1 : 10        # števila od 1 do 10\n#      10 : 1        # števila od 10 do 1\n#      seq(1, 10, 2) # števila od 1 do 10 z razmakom 2\n#      rep(5, 10)    # 10 kopij števila 5\n# \n# Če izpis vektorja sega čez rob okna, nam številka v oglatih oklepajih na\n# začetku vsake vrstice pove trenutni indeks. Sedaj veste, kaj pomeni `[1]`.\n# \n#      1 : 100\n# \n# Običajne matematične operacije brez sprememb delujejo tudi na vektorjih.\n# \n#      2 * (1 : 10)\n#      3 + rep(5, 10)\n#      1 : 5 + seq(50, 10, -10)\n#      1 : 10 ^ 2\n#      (-5 : 5) > 0\n# \n# Če je en vektor krajši od drugega, se ciklično dopolni do daljše dolžine.\n# V primeru, ko daljša dolžina ni večkratnik krajše, dobimo opozorilo.\n# \n#      c(1, 2, 3, 4) + c(10, 20)\n#      c(1, 2, 3, 4) + c(10, 20, 10, 20)\n#      c(1, 2, 3, 4) + c(10, 20, 30)\n# \n# R pozna ogromno funkcij, ki delujejo na vektorjih. Kaj počnejo?\n# \n#      sum(1 : 36)\n#      prod(1 : 10)\n#      mean(c(4, 3, 2, 4, 3, 3, 5))\n# ================================================================@003569=\n# 1. podnaloga\n# Sestavite funkcijo `vsota.kvadratov(n)`, ki vrne vsoto\n# vrne vsoto `1^2 + 2^2 + ... + n^2`.\n# ========================================================================\nvsota.kvadratov <- function(n) {\n  sum((1:n) ^ 2)\n}\n# ================================================================@003570=\n# 2. podnaloga\n# Sestavite funkcijo `alterniraj(v)`, ki vrne vektor, ki ima na lihih mestih\n# enake vrednosti kot `v`, na sodih pa nasprotne.\n# Torej, `alterniraj` na vektorju `2, 5, 1, 7` vrne vektor `2, -5, 1, -7`.\n# Funkcija lahko pri vektorjih lihih dolžin javlja napako.\n# ========================================================================\n\nalterniraj <- function(v) {\n  v * c(1,-1)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# =======================================================================@\n# Kode pod to črto nikakor ne spreminjajte.\n# ========================================================================\n\n\"TA VRSTICA JE PRAVILNA.\"\n\"ČE VAM R SPOROČI, DA JE V NJEJ NAPAKA, SE MOTI.\"\n\"NAPAKA JE NAJVERJETNEJE V ZADNJI VRSTICI VAŠE KODE.\"\n\"ČE JE NE NAJDETE, VPRAŠAJTE ASISTENTA.\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif (length(showConnections()) > 1) {\n  .filename <- showConnections()[1, \"description\"]\n} else {\n  .filename <- Find(Negate(is.null), Map(function(f) { f$ofile }, sys.frames()), right=TRUE)\n}\n\n\n.check <- function() {\n  .error <- FALSE\n.errfun <- function(e) {\n    warning(e)\n    .error <<- TRUE\n}\ntryCatch({\n    library(rjson)\n}, error = .errfun)\ntryCatch({\n    library(httr)\n}, error = .errfun)\n\nif (.error) {\n    stop(\"Required libraries are unavailable. Please make sure that rjson and httr are available.\")\n}\n\nregex_break <- function(whole_regex, regexes, source) {\n    whole_matches <- gregexpr(paste(\"(?sm)\", whole_regex, sep=\"\"), source, perl=TRUE)[[1]]\n    whole_matches <- mapply(\n        function(start, end) substr(source, start, end),\n        whole_matches,\n        whole_matches + attr(whole_matches, \"match.length\") - 1\n    )\n    m <- length(whole_matches)\n    n <- length(regexes)\n    matches <- matrix(\"\", nrow=m, ncol=n)\n    for (i in 1:m) {\n        whole <- whole_matches[i]\n        for (j in 1:n) {\n            rest_regex <- paste(regexes[-(1 : j)], collapse=\"\")\n            part_regex <- paste(\"(?sm)\\\\A\", regexes[j], \"(?=\", rest_regex, \"\\\\Z)\", sep=\"\")\n            match <- regexpr(part_regex, whole, perl=TRUE)\n            end <- attr(match, \"match.length\")\n            matches[i, j] <- substr(whole, 1, end)\n            whole <- substr(whole, end + 1, nchar(whole))\n        }\n    }\n    matches\n}\n\nstrip <- function(str) gsub(\"^\\\\s+|\\\\s+$\", \"\", str)\nrstrip <- function(str) gsub(\"\\\\s+$\", \"\", str)\n\nsuper_strip <- function(str) {\n    str <- gsub(\"(^|\\n)# ?\", \"\\n\", str)\n    gsub(\"\\\\A\\\\s+|\\\\s+\\\\Z\", \"\", str, perl=TRUE)\n}\n\npretty.print <- function(x) {\n  output <- capture.output(print(x))\n  if(length(output) == 0) {\n    return(\"NULL\")\n  } else if(length(output) == 1) {\n    return(output)\n  } else {\n    return(paste(\"    \", c(\"\", output, \"\"), collapse = \"\\n\"))\n  }\n}\n\n\n  check <- list()\n\ncheck$initialize <- function(parts) {\n  init.part <- function(part) {\n    part$valid <- TRUE\n    part$feedback <- list()\n    part$secret <- list()\n    if (part$part) part$id <- part$part\n    return(part)\n  }\n  check$parts <<- lapply(parts, init.part)\n  check$current <<- NA\n  check$part.counter <<- NA\n}\n\ncheck$part <- function() {\n  if(is.na(check$part.counter)) {\n    check$part.counter <<- 1\n  } else {\n    check$part.counter <<- check$part.counter + 1\n  }\n  return(strip(check$parts[[check$part.counter]]$solution) != \"\")\n}\n\ncheck$feedback <- function(msg, ...) {\n  check$parts[[check$part.counter]]$feedback <<-\n    c(check$parts[[check$part.counter]]$feedback, sprintf(msg, ...))\n}\n\ncheck$error <- function(msg, ...) {\n  check$parts[[check$part.counter]]$valid <<- FALSE\n  check$feedback(msg, ...)\n}\n\ncheck$secret <- function(x, hint = \"\") {\n  pair <- c(toString(check$canonize(x)), toString(hint))\n  check$parts[[check$part.counter]]$secret<<-\n    c(check$parts[[check$part.counter]]$secret, list(pair))\n}\n\ncheck$run <- function(example, state) {\n  # yet to be implemented\n}\n\ncheck$canonize <- function(x, digits = 6) {\n  if(typeof(x) == \"double\" || typeof(x) == \"complex\") {\n    return(round(x, digits))\n  } else if(typeof(x) == \"list\") {\n    return(lapply(x, function(y) check$canonize(y, digits)))\n  } else {\n    return(x)\n  }\n}\n\ncheck$equal <- function(example, value = NA, exception = NA,\n                        clean = function(x) x,\n                        precision = 1.0e-6, strict.float = FALSE, check.attributes = FALSE) {\n  difference <- function(x, y) {\n    if(identical(x, y)) return(NA)\n    else if(isTRUE(all.equal(x, y, check.attributes = check.attributes))) return(NA)\n    else if(typeof(x) != typeof(y) && (strict.float || !(mode(x) != mode(y))))\n      return(\"različna tipa\")\n    else if(length(x) != length(y))\n      return(\"različno število komponent\")\n    else if(mode(x) == 'numeric' && mode(y) == 'numeric') {\n      if(any(abs(x - y) > precision))\n        return(\"numerična napaka\")\n      else\n        return(NA)\n    }\n    else return(\"različni vrednosti\")\n  }\n  example <- substitute(example)\n\n  if(!is.na(exception)) {\n    tryCatch({\n      returned <- eval(example)\n      check$error(\"Izraz %s vrne %s namesto da bi sprožil izjemo '%s'.\",\n                  deparse(example), pretty.print(returned), exception)\n    }, error = function(e) {\n      if(e$message != exception)\n        check$error(\"Izraz %s sproži izjemo '%s' namesto '%s'.\",\n                    deparse(example), e$message, exception)\n    })\n  } else {\n    returned <- eval(example)\n    reason <- difference(clean(returned), clean(value))\n    if(!is.na(reason)) {\n      check$error(\"Izraz %s vrne %s namesto %s (%s)\",\n                  deparse(example), pretty.print(returned), pretty.print(value), reason)\n    }\n  }\n}\n\ncheck$random <- function(example, period = 10, sample = 100, uniqueness = 0.9) {\n  example <- substitute(example)\n  results <- replicate(sample, toString(check$canonize(replicate(period, eval(example)))))\n  if (length(unique(results)) < uniqueness * sample) {\n    check$error(\"Izraz %s ne vrača naključnih rezultatov.\", deparse(example))\n  }\n}\n\ncheck$probability <- function(example, interval, sample = 100) {\n  example <- substitute(example)\n  results <- replicate(sample, isTRUE(eval(example)))\n  prob <- sum(results) / sample\n  if (!(interval[1] < prob && prob <= interval[2])) {\n    check$error(\"Izraz %s velja z verjetnostjo %.2f, ki je izven pričakovanega intervala [%.2f, %.2f].\", deparse(example), prob, interval[1], interval[2])\n  }\n}\n\ncheck$expected <- function(example, interval, sample = 100) {\n  example <- substitute(example)\n  results <- replicate(sample, eval(example))\n  prob <- sum(results) / sample\n  if (!(interval[1] < prob && prob <= interval[2])) {\n    check$error(\"Povprečna vrednost izraza %s je %.2f, kar je izven pričakovanega intervala [%.2f, %.2f].\", deparse(example), prob, interval[1], interval[2])\n  }\n}\n\ncheck$summarize <- function() {\n  for(i in 1:length(check$parts)) {\n    if(strip(check$parts[[i]]$solution) == \"\") {\n      cat(\"Podnaloga\", i, \"je brez rešitve.\\n\")\n    } else if (! check$parts[[i]]$valid) {\n      cat(\"Podnaloga\", i, \"nima veljavne rešitve.\\n\")\n    } else {\n      cat(\"Podnaloga\", i, \"ima veljavno rešitev.\\n\")\n    }\n    for (message in check$parts[[i]]$feedback) {\n        cat(\"- \", message, \"\\n\", sep = \"\")\n    }\n  }\n}\n\n  check$challenge <- check$secret\n\n  .source <- paste(readLines(.filename), collapse=\"\\n\")\n\n  matches <- regex_break(paste(\n      '# =+@(\\\\d+)=\\n',    # beginning of header\n      '(#( [^\\n]*)?\\n)+',  # description\n      '# =+\\n',            # end of header\n      '.*?',               # solution\n      '(?=\\n# =+@)',       # beginning of next part\n      sep=\"\"\n  ),  c(\n      '# =+@',             # beginning of header\n      '(\\\\d+)',            # beginning of header (?P<part>)\n      '=\\n',               # beginning of header\n      '(#( [^\\n]*)?\\n)+',  # description\n      '# =+\\n',            # end of header\n      '.*?'                # solution\n  ), .source)\n\n  check$initialize(\n    apply(matches, 1, function(match) list(\n        part = as.numeric(match[2]),\n        solution = match[6]\n      )\n    )\n  )\n  check$parts[[length(check$parts)]]$solution <- rstrip(check$parts[[length(check$parts)]]$solution)\n\n  \n  if (check$part()) {\n    tryCatch({\n      check$equal(vsota.kvadratov(3), 14)\n      check$equal(vsota.kvadratov(4), 30)\n      check$equal(vsota.kvadratov(5), 55)\n      for (i in 1 : 40) {\n        check$secret(vsota.kvadratov(i), paste(\"Koliko je vsota kvadratov do \", i, \"?\"))\n      }\n    },\n    error = function(e) {\n      check$error(\"Testi v izrazu %s sprožijo izjemo %s\", deparse(e$call), e$message)\n    })\n  }\n  \n  if (check$part()) {\n    tryCatch({\n      check$equal(alterniraj(c(2, 5, 1, 7)), c(2, -5, 1, -7))\n      check$equal(alterniraj(c(2, 5, 1, 7, -1, -5)), c(2, -5, 1, -7, -1, 5))\n    },\n    error = function(e) {\n      check$error(\"Testi v izrazu %s sprožijo izjemo %s\", deparse(e$call), e$message)\n    })\n  }\n  \n\n  cat('Shranjujem rešitve na strežnik... ')\n  tryCatch({\n    r <- POST(\n      'https://www.projekt-tomo.si/api/attempts/submit/',\n      body = lapply(check$parts, function(part) {\n        part$secret <- lapply(part$secret, function(x) x[1])\n        part\n      }),\n      encode = \"json\",\n      add_headers(Authorization = 'Token 840c6db2891f669ba2f3e6e7088911585701a262')\n    )\n    response <- content(r)\n    cat('Rešitve so shranjene.\\n')\n    updates <- list()\n    for (part in response$attempts) {\n      updates[[part$part]] <- part\n    }\n    for(i in 1:length(check$parts)) {\n      valid.before <- check$parts[[i]]$valid\n      if (!is.null(updates[[check$parts[[i]]$part]])) {\n        for (field in names(updates[[check$parts[[i]]$part]])) {\n          check$parts[[i]][[field]] <- updates[[check$parts[[i]]$part]][[field]]\n        }\n      }\n      valid.after <- check$parts[[i]]$valid\n      if (valid.before && ! valid.after) {\n        wrong.index <- response$wrong_indices[[as.character(check$parts[[i]]$part)]]\n        if (! is.null(wrong.index)) {\n          hint <- check$parts[[i]]$secret[[wrong.index+1]][2]\n          if (nchar(hint) > 0) {\n            check$parts[[i]]$feedback <- c(check$parts[[i]]$feedback, paste(\"Namig:\", hint))\n          }\n        }\n      }\n    }\n    if(\"update\" %in% names(response)) {\n      cat(\"Posodabljam datoteko... \")\n      index <- 1\n      while(file.exists(paste(.filename, \".\", index, sep = \"\")))\n        index <- index + 1\n      backup.filename = paste(.filename, \".\", index, sep = \"\")\n      file.copy(.filename, backup.filename)\n      r <- readLines(response$update, encoding=\"UTF-8\", warn=FALSE)\n      f <- file(.filename, encoding=\"UTF-8\")\n      writeLines(r, f)\n      close.connection(f)\n      cat(\"Stara datoteka je preimenovana v \", basename(backup.filename), \".\\n\", sep = \"\")\n      cat(\"Če se datoteka v urejevalniku ni osvežila, jo shranite ter ponovno zaženite.\\n\")\n    }\n    check$summarize()\n  },\n  error = function(r) {\n    cat('Pri shranjevanju je prišlo do napake.\\n')\n    check$summarize()\n    cat('Pri shranjevanju je prišlo do napake. Poskusite znova.\\n')\n  })\n}\n\n.check()\n",
    "created" : 1488192096684.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "175152756",
    "id" : "862E3F4B",
    "lastKnownWriteTime" : 1488193126,
    "last_content_update" : 1488193126056,
    "path" : "U:/ANALIZA PODATKOV S PROGRAMOM R/VEKTORJI IN RAZPREDELNICE/osnovni_gradniki_vektorjev.r",
    "project_path" : "osnovni_gradniki_vektorjev.r",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}